import SchemaType from '@/schematype';
import { isPlainObject as _isPlainObject } from 'is-plain-object';
import { getProp } from '@/util';

import type { QueryFilterCallback, QueryDefinition, QueryDefinitionObject, QuerySpecialDefinition } from './types';
import type { ValueType, ValueObject, LeafValueTypes } from '@/types';

const isPlainObject = (obj: unknown): obj is Any =>
  _isPlainObject(obj);

type QueryFn =
  (value: ValueType, query: ValueType, data: ValueObject) => boolean;

export class QueryParser {
  constructor(private paths: Dict<SchemaType>) {}

  /**
   *
   * @param {string} name
   * @param {*} query
   * @return {queryFilterCallback}
   */
  queryStackNormal(name: string, query: LeafValueTypes): QueryFilterCallback {
    const path = this.paths[name] || new SchemaType(name);

    return data => path.match(getProp(data, name), query, data);
  }

  /**
   *
   * @param {string} qkey
   * @param {string} name
   * @param {*} query
   * @return {queryFilterCallback}
   */
  queryStackOperator(qkey: string, name: string, query: LeafValueTypes): QueryFilterCallback {
    const path = (this.paths[name] || new SchemaType(name)) as unknown as Dict<QueryFn>;

    return data => path[qkey](getProp(data, name), query, data);
  }

  /**
   * @param {Array} arr
   * @param stack The function generated by query is added to the stack.
   *
   */
  $and(arr: QueryDefinition[], stack: QueryFilterCallback[]): void {
    for (let i = 0, len = arr.length; i < len; i++) {
      stack.push(this.execQuery(arr[i]));
    }
  }

  /**
   *
   */
  private $or(query: QueryDefinition[]): QueryFilterCallback {
    const stack = this.parseQueryArray(query);
    const len = stack.length;

    return data => {
      for (let i = 0; i < len; i++) {
        if (stack[i](data)) return true;
      }

      return false;
    };
  }

  private $nor(query: QueryDefinition[]): QueryFilterCallback {
    const stack = this.parseQueryArray(query);
    const len = stack.length;

    return data => {
      for (let i = 0; i < len; i++) {
        if (stack[i](data)) return false;
      }

      return true;
    };
  }

  private $not(query: QueryDefinitionObject): QueryFilterCallback {
    const stack = this.parseQuery(query);
    const len = stack.length;

    return data => {
      for (let i = 0; i < len; i++) {
        if (!stack[i](data)) return true;
      }

      return false;
    };
  }

  /**
   *
   */
  $where(fn: (this: ValueObject) => boolean): QueryFilterCallback {
    return data => Reflect.apply(fn, data, []) as boolean;
  }

  /**
   * Parses array of query expressions and returns a stack.
   *
   */
  private parseQueryArray(arr: QueryDefinition[]): QueryFilterCallback[] {
    const stack: QueryFilterCallback[] = [];
    this.$and(arr, stack);
    return stack;
  }

  /**
   * Parses normal query expressions and returns a stack.
   *
   * @param queries
   * @param prefix
   * @param [stack] The function generated by query is added to the stack passed in this argument. If not passed, a new stack will be created.
   */
  private parseNormalQuery(queries: QueryDefinitionObject, prefix: string, stack: QueryFilterCallback[] = []): void {
    const keys = Object.keys(queries);

    for (let i = 0, len = keys.length; i < len; i++) {
      const key = keys[i];
      const query = queries[key];

      if (key[0] === '$') {
        stack.push(this.queryStackOperator(`q${key}`, prefix, query));
        continue;
      }

      const name = `${prefix}.${key}`;
      if (isPlainObject(query)) {
        this.parseNormalQuery(query, name, stack);
      } else {
        stack.push(this.queryStackNormal(name, query));
      }
    }
  }

  /**
   * Parses query expressions and returns a stack.
   *
   */
  private parseQuery(queries: QueryDefinitionObject): QueryFilterCallback[] {

    const stack: QueryFilterCallback[] = [];
    const keys = Object.keys(queries);

    for (let i = 0, len = keys.length; i < len; i++) {
      const key = keys[i];
      const query = queries[key];

      switch (key) {
        case '$and':
          this.$and(query as QuerySpecialDefinition<typeof key>, stack);
          break;

        case '$or':
          stack.push(this.$or(query as QuerySpecialDefinition<typeof key>));
          break;

        case '$nor':
          stack.push(this.$nor(query as QuerySpecialDefinition<typeof key>));
          break;

        case '$not':
          stack.push(this.$not(query as QuerySpecialDefinition<typeof key>));
          break;

        case '$where':
          stack.push(this.$where(query as QuerySpecialDefinition<typeof key>));
          break;

        default:
          if (isPlainObject(query)) {
            this.parseNormalQuery(query, key, stack);
          } else {
            stack.push(this.queryStackNormal(key, query as Query));
          }
      }
    }

    return stack;
  }

  /**
   * Returns a function for querying.
   *
   */
  execQuery(query: QueryDefinitionObject): QueryFilterCallback {
    const stack = this.parseQuery(query);
    const len = stack.length;

    return data => {
      for (let i = 0; i < len; i++) {
        if (!stack[i](data)) return false;
      }

      return true;
    };
  }
}
